# CodeGen
`CodeGen` uses a template based on macro to generate code.

## Basic
There are some basic macro tools in `CodeGen/basic` directory.

### `macro.h`
The `macro.h` defines only two macros:
```C
#define 
#define CAT(A, B) A##_##B
#define MCAT(A, B) CAT(A, B)
```
If `A` or `B` is a macro, the `CAT` could not concatenate them.
Bud if we package them again, the `MCAT` could concatenate them.

### `gnuc.h`
#### Normal part
The `gnuc.h` defines some macros to use the GNU C extensions simply. Such as
```C
#define inline __inline__ __attribute__((always_inline))
#define __malloc __attribute__((malloc))
#define __receive __attribute__((warn_unused_result))
#define likely(x) (__builtin_expect(!!(x), 1))
#define unlikely(x) (__builtin_expect(!!(x), 0))
```
#### RAII part
The most important is the `auto_ptr`.
```C
#define RAII(func) __attribute__((cleanup(func)))

#define Ptr(class) MCAT(class, class_ptr)
#define auto_ptr(class) RAII(MCAT(class, raii)) Ptr(class)
```
The `auto_ptr` is a smart pointer, 
which will call the `MCAT(class, raii)` when it is out of scope.
(RAII is the short for 'Resource Acquisition Is Initialization')
So, we can use it like this:
```C
auto_ptr(Stack) a = Stack_new();
```
where `Stack` is a class, and `Stack_new` is a function to create a `Stack` object.
When it is out of scope, the `Stack_raii` will be called as 
```C
Stack_raii(&a);
```
So, the RAII function should be like this:
```C
void Stack_raii(Stack **stack) {
    ...
}
```

Note that the `a` is declared as `Stack_class_ptr`. 
We should use `DPtr` macro to define this type before.
```C
#define DPtr(class) typedef class * MCAT(class, class_ptr)
```

In addition, this RAII part uses the macro `MCAT` 
to concatenate `class` and other part.
So, there should not be any blank in the `class` name.

For `struct`, `union` and `enum` type, 
we could use `DStruct`, `DUnion` and `DEnum` macro to define them.
Or do it by hand.
```C
#define DStruct(struct_name) typedef struct struct_name struct_name
#define DUnion(union_name) typedef union union_name union_name
#define DEnum(enum_name) typedef enum enum_name enum_name
```

For `unsigned` and other long named int type, 
we could use the type defined in `types.h`.
```C
u_int8_t a;
u_int16_t b;
u_int32_t c;
u_int64_t d;

int8_t e;
int16_t f;
int32_t g;
int64_t h;
```

### `template.h`
The `template.h` is the kernel of `CodeGen`.
The main parts of `template.h` are the macros and shared functions.

#### Macros
```C
#define C(class) MCAT(class, DType)// class name
#define F(func_name) MCAT(Class, func_name) // func name, we should define Class before
#define SF(func_name) MCAT(TClass, func_name) // shared func name, we should define TClass before

#define FuncT_t F(FuncT_t)
#define FuncT F(funcT)
#define classFuncT(class_name, T) MCAT(MCAT(class_name, T), funcT)  
```
These macros uses predefined macros `DType` and `Class` to gen the name.

`C(class)` is used to gen the macro `Class` after defined `DType`.
```C
#define Class C(class_name)
// the `class_name` should be the same with the filename (title case)
```
Then we could use `F(func_name)` to gen the type related functions name of every type.
```C
void F(func_name)(class_name *self, ...);
```
And use `SF(func_name)` to gen the shared func name of every type.
At first, we should define `TClass` before.
```C
#define TClass class_name
// also, the `class_name` should be the same with the filename (title case)

void SF(func_name)(class_name *self, ...);
```

The `FuncT_t` is used to gen the type of func table.
```C
typedef struct FuncT_t FuncT_t;
```

The `FuncT` is used to gen the instance of func table.
```C
static FuncT_t FuncT;
```

The `classFuncT` is used to gen the macro of func table called by users.
```C
#define class_nameT(T) classFuncT(class_name, T)
```

## CodeGen convention
### Struct
All code generated by `template.h` share only one struct.
```C
typedef struct class_name class_name;

struct class_name {
    ...
    void *data; // regard it as different DType * in different func
};
```
The name of this struct should be the same with the filename (title case).

### Shared Function
The shared functions are not related to the `DType`. 
It could use the `SF` macro to gen the name.
```C
void SF(func_name)(class_name *self, ...);
```

There are some normal shared functions.
```C
void SF(delete)(class_name *self);
void SF(raii)(class_name **self);
```
The generated `raii` is compatible with `auto_ptr` in `gnuc.h`.

### Type Related Function
The type related functions are related to the `DType`.
It could use the `F` macro to gen the name.
```C
void F(func_name)(class_name *self, ...);
```

There are some type related functions.
```C
void F(new)(class_name *self, ...);
void F(display)(class_name *self);
```

### Func Table
The func table is used to store the function pointer.
As told before, we could get the last march.
```C
#define class_nameT(T) classFuncT(class_name, T)
```
Then, in our code, we could use the `class_nameT(T)` to get the func table.
Such as:
```C
auto_ptr(Stack) stack = stackT(int).new(10, NULL); 
stackT(int).push(stack, 1);
stackT(int).push(stack, 2);
stackT(int).push(stack, 3);

int tmp = stackT(int).pop(stack);
stackT(int).display(stack);
```

### Name Convention
There are the set of name convention in `CodeGen`.

- class_name : the name of class, snake case, \
first letter upper case. Such as `Static_link`.
- filename : the name of file, same with class_name, \
but lower case. Such as `static_link.h`.
- Func name and Func table name:
  - Func name main part: the main part of func name, camel case, \
  first letter lower case. Such as `appendLeft`.
  - The different parts of name are connected by `_`.
  - Shared func name: class_name + Func name main part.
  - Type related func name: class_name + DType + Func name main part.
  - Func table type name: class_name + DType + `FuncT_t`.
  - Func table instance name: class_name + DType + `FuncT`.
  - Func table macro name: class_name + 'T', specially connected without `_`.